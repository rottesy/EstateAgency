# Технологии и архитектура системы управления агентством недвижимости

В проекте используются Qt6 (модуль Widgets) и стандартная библиотека C++23 для хранения данных в текстовых файлах. Qt обеспечивает кроссплатформенный графический интерфейс, а файловые репозитории заменяют базу данных: все данные о недвижимости, клиентах, сделках и аукционах читаются и записываются в .txt файлы с простым текстовым форматом с разделителями.

## 1 Графический интерфейс на Qt Widgets

Управление окнами и виджетами выполнено на основе QMainWindow, QStackedWidget, QListWidget, QTableWidget, QTextEdit, QLineEdit, QComboBox, QPushButton, QLabel, QDoubleSpinBox, QCheckBox. Приложение использует навигационный список (QListWidget) для переключения между разделами и стек виджетов (QStackedWidget) для отображения соответствующего контента: управление недвижимостью, управление клиентами, управление сделками, управление аукционами, панель управления (дашборд). Таблицы поддерживают сортировку и отображение данных о недвижимости, клиентах, сделках и аукционах с использованием QTableWidget с настраиваемыми заголовками и форматированием ячеек. Для удобства восприятия числовых значений реализована валидация через статические методы классов сущностей (Property::validatePrice, Property::validateArea, Client::validateId, Client::validatePhone, Client::validateEmail) с проверкой диапазонов и форматов. Обновление интерфейса централизовано: после каждой операции вызываются методы refresh() соответствующих виджетов и updateDashboardStats() для обновления статистики на дашборде. Стилизация интерфейса выполнена через QSS (Qt Style Sheets) с темной цветовой схемой и современным дизайном.

## 2 Диалоги, валидаторы и взаимодействие с пользователем

Диалоги оформлены через QDialog с QDialogButtonBox для стандартных кнопок (OK, Cancel, Close). Для ввода данных используются QLineEdit (идентификаторы, адреса, описания), QComboBox (выбор недвижимости и клиентов), QDoubleSpinBox (цены, площади), QTextEdit (описания, примечания), QCheckBox (булевы значения: доступность, балкон, лифт, гараж, сад, парковка, видимость). Валидация выполняется через статические методы классов: проверка непустых строк (Property::validateAddressPart), целых чисел в диапазоне (Property::validateId для 6-8 символов), вещественных чисел в диапазоне (Property::validatePrice для 10000-1000000000, Property::validateArea для положительных значений), корректности форматов (Client::validatePhone для форматов +7XXXXXXXXXX и 8XXXXXXXXXX, Client::validateEmail с использованием регулярных выражений). Сообщения об успехе/ошибках отображаются через QMessageBox::information / warning / critical с детальными описаниями на русском языке. Сигналы и слоты Qt связывают действия кнопок с обработчиками без плотной связности между слоями: виджеты взаимодействуют с менеджерами через указатель на EstateAgency (singleton), что обеспечивает слабую связанность компонентов.

## 3 Формирование детальной информации в формате HTML

Детальная информация о недвижимости, клиентах, сделках и аукционах генерируется в формате HTML и отображается в QTextEdit с поддержкой стилей CSS. HTML включает заголовки с форматированием (h2, h3), параграфы с выделением ключевых полей жирным шрифтом (теги <b>), таблицы для отображения связанных данных (списки сделок, списки ставок), стилизованные блоки для группировки информации. Денежные значения форматируются с фиксированной точностью (2 знака после запятой) через QString::number с параметром 'f' и добавлением единицы измерения "руб.". Площади форматируются аналогично с единицей измерения "м²". Детальная информация включает все характеристики объекта: для недвижимости отображаются базовые поля (ID, тип, адрес, цена, площадь, описание, доступность) и специфические поля в зависимости от типа (для квартир: комнаты, этаж, балкон, лифт; для домов: этажи, комнаты, площадь участка, гараж, сад; для коммерческой недвижимости: тип бизнеса, парковка, места парковки, видимость). Для сделок отображается информация о недвижимости и клиенте, для аукционов – информация о недвижимости и список всех ставок с указанием клиента, суммы и времени. Логика формирования HTML инкапсулирована в методах showPropertyDetails, showClientDetails, showTransactionDetails, showAuctionDetails соответствующих виджетов, что обеспечивает модульность и переиспользуемость кода.

## 4 Хранение данных в текстовых файлах

Данные читаются и записываются через std::ifstream / std::ofstream с использованием текстового формата с разделителем '|' (FILE_DELIMITER). Для объектов недвижимости используется формат: тип|идентификатор|город|улица|дом|цена|площадь|описание|доступность|специфические_поля, где тип может быть APARTMENT, HOUSE или COMMERCIAL; маркеры типов записываются как строковые константы; каждое поле записывается через разделитель; специфические поля для каждого типа записываются после базовых полей (для квартир: комнаты, этаж, балкон, лифт; для домов: этажи, комнаты, площадь участка, гараж, сад; для коммерческой недвижимости: тип бизнеса, парковка, места парковки, видимость); статус доступности записывается как символ '1' (AVAILABLE_CHAR) для доступных и '0' (UNAVAILABLE_CHAR) для недоступных. Для клиентов используется формат: идентификатор|имя|телефон|email|дата_регистрации, где все поля разделены разделителем. Для сделок используется формат: идентификатор|идентификатор_недвижимости|идентификатор_клиента|дата|финальная_цена|статус|примечания. Для аукционов используется формат: идентификатор|идентификатор_недвижимости|адрес|начальная_цена|цена_выкупа|статус|дата_создания|дата_завершения; ставки записываются на отдельных строках с префиксом "BID|" в формате: BID|идентификатор_аукциона|идентификатор_клиента|имя_клиента|сумма|время. Пути к файлам и каталоги создаются через std::filesystem::create_directories, что исключает ошибки из-за отсутствующих директорий. При загрузке выполняется проверка возможности открытия файла: если файл не существует, функция завершается без ошибки, что позволяет системе работать с пустыми данными при первом запуске. При парсинге выполняется обработка пустых строк (пропуск) и некорректных данных (пропуск строки с продолжением загрузки остальных записей).

## 5 Нормализация чисел, точность денег и валидация

Денежные значения обрабатываются в double с принудительным округлением до сотых (копеек) при отображении через QString::number с параметром 'f' и точностью 2. Для устойчивости к пользовательскому вводу выполняется валидация через статические методы классов: проверка диапазонов (Property::validatePrice для 10000-1000000000, Property::validateArea для положительных значений), форматов чисел (Property::validateId для 6-8 цифр), непустых строк (Property::validateAddressPart для адресных компонентов). При парсинге числовых значений из файлов используется обработка исключений std::invalid_argument и std::out_of_range для корректной обработки некорректных данных: при ошибке парсинга строка пропускается, но загрузка продолжается для остальных записей. Валидация идентификаторов выполняется через Property::validateId и Client::validateId с проверкой длины (6-8 символов) и содержания только цифр через std::ranges::all_of. Валидация адресов выполняется через Property::validateAddressPart с проверкой непустоты и максимальной длины (100 символов) и наличия печатаемых символов через std::ranges::any_of.

## 6 Работа со временем и форматами

Даты создания сделок и аукционов хранятся в std::string в формате ISO 8601 (yyyy-MM-dd HH:mm:ss) и генерируются через Utils::getCurrentTimeString с использованием std::chrono::system_clock и std::put_time. Для валидации форматов используется проверка через регулярные выражения (Client::validateEmail) и строковые операции (Client::validatePhone для форматов +7XXXXXXXXXX и 8XXXXXXXXXX). При сохранении даты записываются в текстовом формате как строки, при загрузке парсятся как строки без преобразования. Для форматирования чисел используется QString::number с указанием формата ('f' для вещественных с точностью 2, без параметров для целых) и добавлением единиц измерения ("руб.", "м²"). Для форматирования цен используется утилита Utils::formatPrice, которая добавляет форматирование с двумя знаками после запятой и единицей измерения.

## 7 Организация кода и разделение ответственности

Менеджеры (PropertyManager, ClientManager, TransactionManager, AuctionManager) инкапсулируют бизнес-логику управления коллекциями объектов, предоставляют методы поиска, фильтрации и доступа к данным, не зависят от деталей UI. Сервисы (FileManager) отвечают за файловые операции: сохранение и загрузку данных в текстовом формате с обработкой ошибок и пропуском некорректных записей. Утилиты (Utils) предоставляют функции для работы со строками (toString, toQString, stringContains), форматирования (formatPrice, formatNumber), работы со временем (getCurrentTimeString, getLocalTime), валидации (isNumericId). Хелперы (TableHelper) предоставляют утилиты для работы с таблицами: получение выбранной строки, очистка таблицы, форматирование типов и статусов для отображения. UI-слой (MainWindow, PropertiesWidget, ClientsWidget, TransactionsWidget, AuctionsWidget, DashboardWidget, PropertyDialog, ClientDialog, TransactionDialog, AuctionDialog) занимается сбором ввода и визуализацией результата, вызывая менеджеры и сервисы через четко определенные методы EstateAgency (singleton). Сущности (Property, Apartment, House, CommercialProperty, Client, Transaction, Auction, Bid) инкапсулируют данные и базовую логику работы с ними, включая валидацию через статические методы и форматирование для сохранения через toFileString. Ядро системы (EstateAgency) реализует паттерн Singleton и координирует работу всех менеджеров, обеспечивает централизованное сохранение и загрузку данных через FileManager. Такое разделение упрощает тестирование и модификацию каждого слоя, обеспечивает слабую связанность компонентов и высокую переиспользуемость кода.

